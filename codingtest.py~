#!/bin/python3
import bisect
import collections
import heapq
import math
import os
import random
import re
import sys

#
# Complete the 'gridChallenge' function below.
#
# The function is expected to return a STRING.
# The function accepts STRING_ARRAY grid as parameter.
#

def gridChallenge(grid):
    # Write your code here
    #1) alphabet order
    grid = [sorted(x) for x in grid]

    result = True
    i = 0
    j = 0
    while result:
        if grid[i][j] < grid[i+1][j] and i < len(grid) - 2:
            i += 1
        elif i == len(grid) - 2 and j == len(grid[i]) - 1:
            break
        elif i == len(grid) - 2:
            j += 1
        else:
            print(i)
            result = False

    return "YES" if result else "NO"


    # for i in range(x):
    #     for j in range(grid[i]):
    #         grid[i][j]
    # for i in range(len(grid)):
    #      print(sorted(grid[i]))

def superDigit(n, k):
    def super_digit(n):
        if len(n) == 1:
            return n

        sum = 0
        for i in n:
            sum += int(i)
        return str(sum)

    p = n * k
    while len(p) != 1:
        p = super_digit(p)

    return p
    # # return int(n) * k
    # #return str(n)[0]

def minimumBribes(q):
    #...stack?
    pos = range(len(q)+1)
    org = range(len(q) + 1)
    p = [0] * len(q)
    for i in range(len(q)-1, -1, -1):
        oldp = pos[q[i]]
        newp = i + 1
        while oldp != newp:
            p[oldp-1] += 1
            if p[oldp-1] > 2:
                return "Too chaotic"
                break
            print(org[2])
            temp = org[oldp]
            print(org[oldp+1])
            org[oldp] = org[oldp+1]
            org[oldp+1]  = temp
            #org[oldp], org[oldp+1] = org[oldp + 1], org[oldp]

            print(org)
            #pos[q[oldp]] = oldp
            print(oldp)
            print(p)
            print(q)

    for x in p:
        if x > 2:
            return "Too chaotic"
    return sum(p)

def dy(n):
    dp = collections.defaultdict(list)

    for i in range(len(n)):
        print(i)
        if i == 0:
            dp[i].append(n[0])
            print(dp)
        elif n[i] > n[i-1]:
            lst = dp[i-1].copy()
            lst.append(n[i])
            dp[i].append(lst)
            print(dp)
        else:
            print("555")
            # for j in range(len(dp)-2, -1, -1):
            #     if n[j] < n[i]:
            #         dp[i] = n[i] + dp[j]
    print(dp)

def password(s, keypad):
    p, q = 0, 0
    p_lst = [0, 1, 0, -1, 1, -1, 1, -1]
    q_lst = [-1, 0, 1, 0, 1, -1, -1, 1]

    pad = [[],[],[]]
    srt = s[0]

    for i in range(len(keypad)):
        if i <= 2:
            pad[0].append(keypad[i])
        elif i <= 5:
            pad[1].append(keypad[i])
        else:
            pad[2].append(keypad[i])
        if keypad[i] == srt:
            p = i // 3
            q = i % 3
    print(pad)
    print(p)
    print(q)
    Q = [(0, (p, q), 0)] #위치  src , 시간 K
    #

    for x in range(1, len(s)):
        if s[x-1] == s[x]:
            continue

        while Q:
            # if x == len(s):
            #     break
            if pad[p][q] == s[x]:
                break

            k, (p, q), distance = heapq.heappop(Q)
            #distance += 1
            print("-------", distance, p, q, "rq", s[x])
            if pad[p][q] == s[x]:
                print("zzzzzzzzzzz", distance, p, q, k)
                heapq.heappush(Q, (k, (p, q), distance))
                break
            else:
                distance += 1
                k += 1
                #distance, (p, q), k = heapq.heappop(Q)
                for z in range(7):
                        if 0 <= p + p_lst[z] <=2 and 0 <= q + q_lst[z] <= 2:
                            if k == 1:
                                print("qqqqqq", distance, p + p_lst[z], q + q_lst[z], k)
                                heapq.heappush(Q, (k, (p + p_lst[z], q + q_lst[z]), distance))
                            if k == 1 and pad[p + p_lst[z]][q + q_lst[z]] == s[x]:
                                print("distc", distance, s[x], pad[p + p_lst[z]][q + q_lst[z]], p + p_lst[z],
                                      q + q_lst[z])
                                heapq.heappush(Q, (0, (p + p_lst[z], q + q_lst[z]), distance))
                                break
                            if k ==2 and pad[p+p_lst[z]][q+q_lst[z]] == s[x]:
                                print("distc", distance,s[x], pad[p+p_lst[z]][q+q_lst[z]],p+p_lst[z], q+q_lst[z])
                                heapq.heappush(Q, (0, (p + p_lst[z], q + q_lst[z]), distance))
                                break
                # if pad[p+p_lst[z]][q+q_lst[z]] == s[len(s)-1]:
                #     break
    return distance

                            #print("qqqqqq", distance, p + p_lst[z],  q + q_lst[z], k)




        # 3    return distance + 1
        #
        # if k >= 0:
        #
        #     #아니라면 집어넣어
        #
        #return distance -1


def tf(weight):
    #weight = sorted(weight)
    dp = collections.defaultdict(float)
    #dp[0].append(weight[0])
    dp[0] += weight[0]

    print(dp)
    for i in range(1, len(weight)):
        print("iiiiiii", i)
        for j in range(0, i+1):

            #if sum(dp[j]) + weight[i] <= 3:
            if min(dp.values()) + weight[i] <= 3:
                print("ttttttt", i,weight[i])
                #dp[j].append(weight[i])
                dp[j]+=(weight[i])
                print(dp)

                break
            # else:
            #     print("asdfasdfsadf", weight[i])
            #     dp[i].append(weight[i])
            #break
    print(dp)
    print(min(dp.values()))
    print(dp.fromkeys(min(dp.values())))
   # print(dp.keys()[min(dp.values())])
    count = 0

    for _ in dp:
        count += 1

    return count

    # for d in dp:
    #     print(d)

def card(cards):
    #cards.sort()
    #print(cards)
    #cards=collections.deque(cards)
    #print(cards.popleft())

    def solu(cards):
        #print(cards[1::2])
        #print(cards[0::2])
        # cards = collections.deque(cards)
        # beroni = []
        # kero = []
        #
        # i = 0
        # while cards:
        #     if i %2 == 0:
        #         beroni.append(cards.popleft())
        #     else:
        #         kero.append(cards.popleft())
        #     i += 1
        # print(sum(beroni), sum(kero))
        return sum(cards[1::2]) == sum(cards[0::2])

    #return solu(cards)
    #sum(cards)
    p  = sum(cards[1::2]) - sum(cards[0::2])
    #print(p)
    #l = bisect.bisect_left(cards, p)
    cards.index(p)
    #print(".lll", l)
    lo = 0
    hi = len(cards)
    #for i in range(0, len(cards)):
    #cards.sort()
    print(cards)
    while lo <= hi:
        i = (lo + hi)//2
        print("iiii", i)
        card_t = cards[:i] + cards[i+1:]
        print(card_t)

        #print(solu(card_t))
        print(card_t[1::2])
        print(card_t[0::2])
        if sum(card_t[1::2]) == sum(card_t[0::2]):
            print("완성")
            return i
        elif sum(card_t[1::2]) > sum(card_t[0::2]):
            print("홀 커")
            hi = i - 1

        else:
            print("짝 커 ")
            lo = i + 1
    print(lo)
    print(hi)
    print(i)
    return -1
        # if solu(card_t):
        #     return i + 1 #index

if __name__ == '__main__':
    #print(password("523817","371648295"))
    #print(password("3999","735194826"))
    #print(password("13722327","481729356"))
    print(tf([1.01, 1.99, 2.5, 1.5, 1.01]))
    #print(tf([1.4, 1.01, 2.4, 1.01, 1.01]))
    #print(tf([1.991, 1.4, 1.01, 1.32]))
    #print(card([2,5,3,1]))
    #print(card([2,5,2,7,8,4]))

    # dy([10, 20, 10, 30, 20, 50])
    #
    # grid = ['ebacd', 'fghij', 'olmkn', 'trpqs', 'xywuv']
    # result = gridChallenge(grid)
    # #print(result)
    #
    # #recursion , dp ...?
    # result = superDigit("9875", 4)
    #
    # result = superDigit("148", 3)

    #print(result)

    #print(minimumBribes([2, 1, 5, 3, 4]))
    #print(minimumBribes([2, 5, 1, 3, 4]))

    #print(minimumBribes([1, 2, 5, 3, 4, 7, 8, 6]))
    #print(minimumBribes([5, 1, 2, 3, 7, 8, 6, 4]))
    #print(minimumBribes([1, 2, 5, 3, 7, 8, 6, 4]))
